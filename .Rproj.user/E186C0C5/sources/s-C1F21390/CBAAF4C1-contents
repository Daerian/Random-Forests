---
title: "STAC32 A8"
author: "Daerian Dilkumar"
date: '2017-11-08'
output:
  pdf_document: default
  html_document: default
---
\center{
UTorID:            dilkumar,
}
\center{
Student Number:    1000356198
}
\clearpage
\tableofcontents
\clearpage
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Question 11

## Introduction

The aim of this analysis is to find out which song topped the list for the greatest amount of time. We will conduct our analysis through a series of pipes, since the data set containingt he information we need is untidy, and requires work to propperly sort.
We begin by first importing the libraries required

```{r}
library(tidyverse)
library(smmr)
```

##  PART A

We read in the data and then we will take a look to see if it was correctly parsed.
```{r}
charts = read_csv("billboard.csv") # read the data
spec(charts) # check if columns of correct type
charts  # see if the values parsed as wanted
```

## PART B

We find that many of the songs are not on the buildboard, so we will split the columns to represent better the data we seek. We instead use two columns, one to represent the week number and one to represent the rank of the song that week. This way we can get rid of values such as "N/A" which hold no meaning or value for our purposes.


```{r}
charts %>% gather(week, rank, x1st.week:x76th.week, na.rm = T)

```

This new dataframe shows many more rows however we have reduced the number of variables we had to 9. This is because we have removed all the "empty" values and instead made a new row for every week-rating combo that DOES exist. The rows are grouped by week number, so some groupings have less or more rows than others, since some songs only appear on the billboard during certain weeks.


## PART C

We will now view just the two new columns

```{r}
charts %>% gather(week, rank, x1st.week:x76th.week, na.rm = T) %>% select(week,rank)
```


## PART D

Now we change the values from chars to numbers as they should be
```{r}
charts %>% gather(week, rank, x1st.week:x76th.week, na.rm = T) %>%
  mutate(week=parse_number(week),rank=parse_integer(rank)) %>% select(week,rank)
```

When we look above, we see that the columns are now both accurately parsed as numbers. more specifically they are parsed as integers.


## PART E

Since the week number represents the weke SINCE entering (week 1 is the day of entering)
we will create a new column to give us the specific days

```{r}
charts %>% gather(week, rank, x1st.week:x76th.week, na.rm = T) %>%
  mutate(week=parse_number(week),rank=parse_integer(rank)) %>%
  mutate(current=((week -1 )*7) + date.entered) %>% select (date.entered,week,current)
```

Now we can see the actual date that corresponds to each measurement

## PART F

We can now see which songs have reached #1 status. Let us take a look

```{r}
charts %>% gather(week, rank, x1st.week:x76th.week, na.rm = T) %>%
  mutate(week=parse_number(week),rank=parse_integer(rank)) %>% 
  mutate(current=((week -1 )*7) + date.entered) %>% 
  filter(rank==1) %>% select(current,artist.inverted,track) %>% arrange(current)
```

We see above all songs that ranked number 1 in order of the date in which they took the number 1


## PART G

Now we search for the song that topped the list the greatest amount of times
```{r}
charts %>% gather(week, rank, x1st.week:x76th.week, na.rm = T) %>%
  mutate(week=parse_number(week),rank=parse_integer(rank)) %>% 
  mutate(current=((week -1 )*7) + date.entered) %>% 
  filter(rank==1) %>% select(current,artist.inverted,track) %>% 
  arrange(current) %>% count(track) %>% arrange(desc(n)) %>% head(1)
```

We then see that the song that tops the list the most is Independent Women Part I which ranks 1 in 11 weeks.

## Conclusion. 
We see then through our work that the song that has topped the charts the most number of times is Independent Women Part I by Aguilera, Christina, and it hit the top spot 11 times


# Question 12

## Introduction

From the question given we have the following information:
In forestry, the financial value of a tree is the volume of wood that it contains. This
is difficult to estimate while the tree is still standing, but the diameter is easy to measure with a tape measure (to measure the circumference) and a calculation involving $\pi$, assuming that the cross-section of the tree is at least approximately circular. The standard measurement is “diameter at breast height” (that is, at the height of a human breast or chest), defined as being 4.5 feet above the ground.

Several pine trees had their diameter measured shortly before being cut down, and for each tree, the volume of wood was recorded.  The diameter is in inches and the volume is in cubic inches. We will aim to answer the following question: "Is it possible to predict the volume of wood from the diameter?"


## PART A

We will begin by first obtaining the aforemenioned recordings and putting thme into a data frame. Then we will make sure that it has been parsed correctly and all values are as they should be.
```{r}
pines = read_delim('pinetrees.txt'," ")
glimpse(pines)
```

When we observe the data above we can see that all values have been placed where they should be and how they should be.

## PART B

We can now plot the recordings to see if there exists any evidence for what we are searching for

```{r}
plot(pines$volume~pines$diameter, xlab = "Diameter (inches)", ylab = "volume (cubic inches)")
```

Upon inspection of the plot we created, as can see that there seems to be a type of correlation between diameter and volume, since as diameter increases, so too does volume.

## PART C

The visual representation of the relationship between these variables seem to be linear. We see that we might be able to fit a line-of-best-fit to the plot and use it to calculate approximately the volume of a tree given it's diameter.
```{r}
reg = lm(pines$volume~pines$diameter)
coefs = coef(reg)
plot(pines$volume~pines$diameter, xlab = "Diameter (inches)", ylab = "volume (cubic inches)")
coefs
abline(coefs)
```

As we can see from above, there exists a good fit via linear model. The values tell us that on average as diameter increases by one inch, volume increases by 10.9 cubic inches.

## PART D

We fitted above a linear model, so now we will obtain a summary of the model and try to interprest it's meaning

```{r}
summary(reg)
```

We see above that we have an $R^2$ values of 0.9585.
$R^2$ is a value which explains how close the true data is to the fitted values. It shows what % of the data that the model gets correct. So 95.85% of the data is predicted correctly by the model, and the model is an excellent way to predict volume given diameter.

## PART E

Keeping this in mind, once again we can look at the graph to see exactly how well the model works

```{r}
plot(reg$residuals~reg$fitted, xlab = "Fitted Values", ylab = "Residuals")
abline(0,0) # Zero line
abline(-3,0,lty = 2) # -3 boundary for linear models
abline(3,0,lty = 2) # +x3 boundary for linear models
```


The residulas show that the values are not between -3 and 3. Therefore we find the linear model is in reality a bad way of describing the data


## PART F

It is important to note that by our model, the diameter of a 0 diamter tree is negative. However since this cannot happen, we must predict that the value is 0 exactly, which is NOT what the model says.


## PART G

From a quick google search, we see that the formula is as follows:
$V= \frac{1}{3}\pi hr^2$.
In other words, if we were to model volume as a function of diameter we first divide the diameter by two to get radius, then plug it into the formula above.

OR we can convert to using diameter it self by plugging r = $\frac{d}{2}$
We then get the following formula:
$V= \frac{1}{3}\pi hr^2 \rightarrow V= \frac{1}{3}\pi h(\frac{d}{2})^2 \rightarrow V= \frac{1}{12}\pi hd^2$.
Then, we instead use the formula $V= \frac{1}{12}\pi hd^2$.


## PART H

We will assume that all the pines are of roughly the same height and simply use h = 1 as a constant value to calculate

```{r}
V = ((((1/12) * pi) * 1) * (pines$diameter)^2)
reg2 = reg = lm(V~pines$diameter)
coef2 = coef(reg2)
plot(reg2$fitted~pines$diameter, xlab = "Diameter (inches)", ylab = "volume (cubic inches)")
abline(coef2)
```